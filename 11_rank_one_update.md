# DGEMM最適化:ランク-1アップデート法

## 基本的な行列乗算の理解

行列乗算は、2つの行列から新しい行列を生成する基本的な演算です。2つの行列 $`A`$ (サイズ $`M \times K`$) と $`B`$ (サイズ $`K \times N`$) の積 $`C = A \times B`$ (サイズ $`M \times N`$) を考えます。

最も基本的な実装では、結果行列 $`C`$ の各要素 $`C_{ij}`$ は以下のように計算されます:

```math
$$ C_{ij} = \sum_{k=1}^{K} A_{ik} \times B_{kj} $$
```

この方法では、$`C`$ の各要素を計算するたびに、行列 $`A`$ の行と行列 $`B`$ の列をメモリから読み出す必要があります。具体的には、1つの要素を計算するために $`2K`$ 個の値($`A`$ から $`K`$ 個、$`B`$ から $`K`$ 個)をメモリからロードします。

## ランク-1アップデート法について

ランク-1アップデート法は、行列乗算の効率を高めるための手法です。この手法の基本的な考え方は、行列乗算を一連のランク-1行列の加算として表現することです。

行列 $`A`$ の列ベクトル
```math
a_k = A_{:,k} =
\begin{bmatrix}
  a_{1k} \\
  a_{2k} \\
  \vdots \\
  a_{m_R\,k}
\end{bmatrix}
```

行列 $`B`$ の行ベクトル 

```math
b_k^{\mathsf T} = B_{k,:}=\begin{bmatrix} b_{k1} & b_{k2} & \dots & b_{k\,n_R} \end{bmatrix} 
```

これらの外積 $`a_k\,b_k^{\mathsf T}`$ はランク 1 の行列になり、全体の積は以下のようにランク 1 行列の和として書き直せます。

```math
$$
C = \sum_{k=1}^{K} a_k\,b_k^{\mathsf T}
\quad
(\text{with } a_k = A_{:,k},\; b_k^{\mathsf T} = B_{k,:})
$$
```

```math
C = \begin{bmatrix} C_{11} & C_{12} & \dots & C_{1\,n_R} \\ C_{21} & C_{22} & \dots & C_{2\,n_R} \\ \vdots & \vdots & \ddots & \vdots \\ C_{m_R\,1} & C_{m_R\,2} & \dots & C_{m_R\,n_R} \end{bmatrix} = \sum_{k=1}^{K} \; \begin{bmatrix} a_{1k}\\ a_{2k}\\ \vdots\\ a_{m_R\,k} \end{bmatrix} \! \begin{bmatrix} b_{k1} & b_{k2} & \dots & b_{k\,n_R} \end{bmatrix} 
``` 

## メモリアクセス回数の比較

小行列(マイクロカーネル)のサイズを $`m_R \times n_R`$ とした場合のメモリアクセス回数を比較してみましょう。

### 基本的な実装(ドット積方式)

結果行列 $`C`$ の各要素($`m_R \times n_R`$ 個)について、それぞれ $`A`$ から $`K`$ 個、$`B`$ から $`K`$ 個の要素を読み込みます:

- 合計メモリアクセス回数 = $`2K \times m_R \times n_R`$

### ランク-1アップデート方式

$`C`$ の小行列ブロック全体をレジスタに保持し、各イテレーションでは:
- $`A`$ から $`m_R`$ 個の要素(1列)
- $`B`$ から $`n_R`$ 個の要素(1行)
をロードします。

- 合計メモリアクセス回数 = $`K \times (m_R + n_R)`$

### 削減率の計算

メモリアクセス削減率は次の式で表されます:

```math
$$ \frac{2m_R \times n_R \times K}{(m_R+n_R)K} = \frac{2m_R \times n_R}{m_R+n_R} $$
```

## 具体例による比較

### 2×2行列の場合

最もシンプルな2×2行列の乗算で比較してみましょう：

行列 $`A`$ と $`B`$:
```
A:            B:
[ a11 a12 ]   [ b11 b12 ]
[ a21 a22 ]   [ b21 b22 ]
```

#### 基本的な実装
各要素を個別に計算します：

- C[0,0]の計算：
  - Aの1行目をロード：[a11, a12]（2要素）
  - Bの1列目をロード：[b11, b21]（2要素）
  - 計算：a11×b11 + a12×b21

- C[0,1]の計算：
  - Aの1行目を再ロード：[a11, a12]（2要素）
  - Bの2列目をロード：[b12, b22]（2要素）
  - 計算：a11×b12 + a12×b22

- C[1,0]およびC[1,1]も同様に計算

**合計メモリアクセス**: 2×2×2×2 = 16回

#### ランク-1アップデート方式
行列C全体をレジスタに保持します：

1. Cをゼロで初期化
2. 第1イテレーション：
   - Aから1列目をロード：[a11, a21]（2要素）
   - Bから1行目をロード：[b11, b12]（2要素）
   - 外積計算と累積：
     ```
     C += [ a11 ] × [ b11 b12 ]
          [ a21 ]
     ```

3. 第2イテレーション：
   - Aから2列目をロード：[a12, a22]（2要素）
   - Bから2行目をロード：[b21, b22]（2要素）
   - 外積計算と累積

**合計メモリアクセス**: (2+2)×2 = 8回（**50%削減**）

### 大きな行列ブロックの場合

$`m_R = n_R = 4`$ の場合：
```math
$$ \frac{2 \times 4 \times 4}{4 + 4} = \frac{32}{8} = 4 $$
```
メモリアクセスが**1/4**に削減されます。

$`m_R = n_R = 8`$ の場合：
```math
$$ \frac{2 \times 8 \times 8}{8 + 8} = \frac{128}{16} = 8 $$
```
メモリアクセスが**1/8**に削減されます。

## 実装における考慮点

ランク-1アップデート方式の効率は、行列ブロックをレジスタに保持できることが前提です。例えば、Ryzen 3970Xでは、AVX2命令セットで16本の256bitレジスタ（YMM0-YMM15）が利用可能であり、倍精度浮動小数点数（64bit）なら最大で64個の値を保持できます。つまり、理論上は8×8のブロックサイズまで対応可能ですが、レジスタスピル（レジスタ不足によるメモリへの退避）を避けるため、実際には少し小さめのブロックサイズを選ぶことが一般的です。

実装では、レジスタ上での操作を最適化し、AVX2、FMA（Fused Multiply-Add）命令を活用することで、binary64(倍精度)で1サイクルあたり最大16 FLOP、binary32(単精度)で、最大32FLOPの性能を引き出すことが可能です。

## 歴史的なこと
現代のコンピュータシステムでは、低ランク外積演算によるメモリ効率の向上が極めて重要です。この重要性は、コンピュータハードウェアの歴史的な変遷に由来しています。
かつてはメモリのアクセス速度が演算処理速度を上回っていましたが、1990年頃からこの関係が逆転し始めました。[streamベンチマーク](https://www.cs.virginia.edu/stream/)でも示されているように、プロセッサの演算能力が飛躍的に向上する一方で、メモリの物理的特性による制約からアクセス速度の向上には限界があります。この「メモリウォール」と呼ばれる問題に対処するため、キャッシュの効率的活用が不可欠となりました。特に大規模な行列計算においては、演算量とメモリアクセス量の比率を最適化することが性能向上の鍵となります。S. W. White; S. Dhawanによる1994年[POWER2: next generation of the RISC System/6000 family](https://doi.org/10.1147/rd.385.0493)で外積形式での実装が初めて行われたようです。他にも、文献は出ています。
数理的な観点からは、2001年に出版されたJohn A. Gunnels, Greg M. Henry & Robert A. van de GeijnによるComputing in Science & Engineeringの[A Family of High-Performance Matrix Multiplication Algorithms](https://link.springer.com/chapter/10.1007/3-540-45545-0_15)が重要な貢献をしています。この研究では、ランク1更新（rank-1 update）を用いた行列積アルゴリズムについて、詳細な数理的コストモデルと最適なブロッキング手法が提案されました。この研究により、キャッシュ階層を意識したメモリアクセスパターンと演算順序の最適化が可能となり、現代の高性能行列計算ライブラリの理論的基盤が確立されました。さらに2008年のKazushige Goto, Robert A. van de Geijnによる[Anatomy of High-Performance Matrix Multiplication](https://www.cs.utexas.edu/~flame/pubs/GotoTOMS_revision.pdf)[ACMの論文](https://dl.acm.org/doi/10.1145/1356052.1356053)がモダンなアーキテクチャでのGEMMのまとめになっています。コンピュータアーキテクチャの発展において、メモリと演算速度のギャップは継続的な課題であり、低ランク外積演算を活用した最適化手法は、この課題に対する重要なブレークスルーとなりました。現代の科学技術計算や機械学習の基盤となる高性能行列演算は、これらの歴史的な技術革新に支えられています。
[chatgpt deep researchの結果](https://chatgpt.com/share/680b2092-4abc-800e-8ba6-103cdf7ca091)。間違いの指摘は歓迎です。ぜひ教えてください。

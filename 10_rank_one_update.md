# ランク-1アップデートによるDGEMM最適化

## ナイーブ実装の問題点

行列乗算（DGEMM）の最も単純な実装では、ドット積を用いて結果行列 $`\bar{C}`$ の各要素を計算します。この方法では、$`\bar{C}`$ の各要素を計算するたびに主記憶から $`2K`$ 個の要素を読み出す必要があります。ブロック全体では $`2K \cdot m_R \cdot n_R`$ 個のメモリロードが発生し、これはメモリ帯域幅のボトルネックとなります。

## レジスタ積み上げ方式（アウトプロダクト法）

この問題を解決するため、レジスタを効率的に活用するアウトプロダクト法を用います：

1. $`\bar{C}`$ をゼロで初期化し、全体をレジスタに保持します（$`m_R`$, $`n_R`$ が小さいため可能）
2. $`k = 1 \ldots K`$ について繰り返し：
   - $`\bar{A}`$ の1列と $`\bar{B}`$ の1行をロード
   - それらの外積を計算し、結果を $`\bar{C}`$ に累積

このアプローチの核心となるのが**ランク-1アップデート**（rank-1 update）と呼ばれる操作です。

## ランク-1アップデートの詳細

### 理論的背景

ランク-1行列とは、ベクトル $`x \in \mathbb{R}^{m_R}`$ と $`y \in \mathbb{R}^{n_R}`$ の外積 $`x y^T`$ で生成される行列であり、その行列のランクが1であることを示します。

マイクロカーネルでは、各イテレーションで次のランク-1アップデート操作を行います：

```math
\bar{C} \;+=\; x \, y^T
```

これは、現在の $`\bar{C}`$ の値にランク-1行列 $`x y^T`$ を加算する操作です。行列乗算全体を複数のランク-1アップデートの和として表現することで、メモリアクセスを大幅に削減できます。

![ランク1アップデート](rankone_update.svg)

### ランク-1アップデート方式の効率性

ランク-1アップデート方式では、メモリアクセスを大幅に削減できます。具体的には以下のようになります:

#### 要素数の比較

- **ランク-1アップデート**: 読み込む要素数 = $`(mR + nR)K`$ 個
- **ナイーブ実装**: 読み込む要素数 = $`2mRnRK`$ 個

#### 削減比率

削減の比率は次の式で表されます:

```math
$$ \frac{2m_Rn_RK}{(m_R+n_R)K} = \frac{2m_Rn_R}{m_R+n_R} $$
```

#### 具体例

例えば、`m_R = n_R = 4` の場合:

```math
$$ \frac{2 \cdot 4 \cdot 4}{4 + 4} = \frac{32}{8} = 4 $$
```

つまり、メモリアクセスが**1/4**に削減されます。

さらに、`m_R = n_R = 8` の場合:

```math
$$ \frac{2 \cdot 8 \cdot 8}{8 + 8} = \frac{128}{16} = 8 $$
```

このケースでは、メモリアクセスが**1/8**にまで削減されます。

### スケーリング特性

$`m_R`$ と $`n_R`$ の値が大きくなるほど、この削減効果はさらに増大します。これは特に大規模な行列演算において顕著な効率改善をもたらします。理論的には、これらの値が大きければ大きいほど、メモリアクセスの削減効果は向上します。

しかし、実際の実装では、`m_R` と `n_R` の値は利用可能なレジスタメモリによって制約されます。レジスタは高速だが容量が限られているメモリであるため、無限に大きな値を設定することはできま せん。したがって、ハードウェアの制約の中で最適な値を選択する必要があります。

### 実装例

以下は、レジスタ上での実装の疑似コード例です：

```
// レジスタにロード済みのベクトル A_reg[0..m_R-1], B_reg[0..n_R-1] を用いる
for i in 0..m_R-1:
    for j in 0..n_R-1:
        C_reg[i * ldc + j] += A_reg[i] * B_reg[j]
```

この実装では、`ldc`（leading dimension of C）を使用して行列Cのメモリレイアウトを正確に表現しています。この操作は、すべてのメモリアクセスをレジスタ内の読み書きに置き換え、メモリ帯域幅の制約を回避します。演算コストは $`m_R \times n_R`$ の乗算累加（multiply-accumulate）であり、FMA（Fused Multiply-Add）命令を用いることで1サイクルあたり最大2 FLOPを実現可能です。

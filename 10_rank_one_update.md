# 行列乗算(DGEMM)最適化:ランク-1アップデート法

## 基本的な行列乗算の理解

行列乗算は、2つの行列から新しい行列を生成する基本的な演算です。2つの行列 $`A`$ (サイズ $`M \times K`$) と $`B`$ (サイズ $`K \times N`$) の積 $`C = A \times B`$ (サイズ $`M \times N`$) を考えます。

最も基本的な実装では、結果行列 $`C`$ の各要素 $`C_{ij}`$ は以下のように計算されます:

```math
$$ C_{ij} = \sum_{k=1}^{K} A_{ik} \times B_{kj} $$
```

この方法では、$`C`$ の各要素を計算するたびに、行列 $`A`$ の行と行列 $`B`$ の列をメモリから読み出す必要があります。具体的には、1つの要素を計算するために $`2K`$ 個の値($`A`$ から $`K`$ 個、$`B`$ から $`K`$ 個)をメモリからロードします。

## ランク-1アップデート法とは

ランク-1アップデート法は、行列乗算の効率を高めるための手法です。この手法の基本的な考え方は、行列乗算を一連のランク-1行列の加算として表現することです。

ランク-1行列とは、列ベクトル $`a`$ と行ベクトル $`b^T`$ の外積 $`a \times b^T`$ で表される行列のことです。この行列のランクは1です。

行列乗算全体は、以下のように分解できます:

```math
$$ C_{ij} = \sum_{k=1}^{K} A_{i,k} \times B_{k,j} $$
```
この式は、行列 $`C`$ が $`K`$ 個のランク-1行列の和であることを示しています。

## メモリアクセス回数の比較

小行列(マイクロカーネル)のサイズを $`m_R \times n_R`$ とした場合のメモリアクセス回数を比較してみましょう。

### 基本的な実装(ドット積方式)

結果行列 $`C`$ の各要素($`m_R \times n_R`$ 個)について、それぞれ $`A`$ から $`K`$ 個、$`B`$ から $`K`$ 個の要素を読み込みます:

- 合計メモリアクセス回数 = $`2K \times m_R \times n_R`$

### ランク-1アップデート方式

$`C`$ の小行列ブロック全体をレジスタに保持し、各イテレーションでは:
- $`A`$ から $`m_R`$ 個の要素(1列)
- $`B`$ から $`n_R`$ 個の要素(1行)
をロードします。

- 合計メモリアクセス回数 = $`K \times (m_R + n_R)`$

### 削減率の計算

メモリアクセス削減率は次の式で表されます:

```math
$$ \frac{2m_R \times n_R \times K}{(m_R+n_R)K} = \frac{2m_R \times n_R}{m_R+n_R} $$
```

## 具体例による比較

### 2×2行列の場合

最もシンプルな2×2行列の乗算で比較してみましょう：

行列 $`A`$ と $`B`$:
```
A:            B:
[ a11 a12 ]   [ b11 b12 ]
[ a21 a22 ]   [ b21 b22 ]
```

#### 基本的な実装
各要素を個別に計算します：

- C[0,0]の計算：
  - Aの1行目をロード：[a11, a12]（2要素）
  - Bの1列目をロード：[b11, b21]（2要素）
  - 計算：a11×b11 + a12×b21

- C[0,1]の計算：
  - Aの1行目を再ロード：[a11, a12]（2要素）
  - Bの2列目をロード：[b12, b22]（2要素）
  - 計算：a11×b12 + a12×b22

- C[1,0]およびC[1,1]も同様に計算

**合計メモリアクセス**: 2×2×2×2 = 16回

#### ランク-1アップデート方式
行列C全体をレジスタに保持します：

1. Cをゼロで初期化
2. 第1イテレーション：
   - Aから1列目をロード：[a11, a21]（2要素）
   - Bから1行目をロード：[b11, b12]（2要素）
   - 外積計算と累積：
     ```
     C += [ a11 ] × [ b11 b12 ]
          [ a21 ]
     ```

3. 第2イテレーション：
   - Aから2列目をロード：[a12, a22]（2要素）
   - Bから2行目をロード：[b21, b22]（2要素）
   - 外積計算と累積

**合計メモリアクセス**: (2+2)×2 = 8回（**50%削減**）

### 大きな行列ブロックの場合

$`m_R = n_R = 4`$ の場合：
```math
$$ \frac{2 \times 4 \times 4}{4 + 4} = \frac{32}{8} = 4 $$
```
メモリアクセスが**1/4**に削減されます。

$`m_R = n_R = 8`$ の場合：
```math
$$ \frac{2 \times 8 \times 8}{8 + 8} = \frac{128}{16} = 8 $$
```
メモリアクセスが**1/8**に削減されます。

## 実装における考慮点

ランク-1アップデート方式の効率は、行列ブロックをレジスタに保持できることが前提です。例えば、Ryzen 3970Xでは、AVX2命令セットで16本の256bitレジスタ（YMM0-YMM15）が利用可能であり、倍精度浮動小数点数（64bit）なら最大で64個の値を保持できます。つまり、理論上は8×8のブロックサイズまで対応可能ですが、レジスタスピル（レジスタ不足によるメモリへの退避）を避けるため、実際には少し小さめのブロックサイズを選ぶことが一般的です。

実装では、レジスタ上での操作を最適化し、FMA（Fused Multiply-Add）命令を活用することで、1サイクルあたり最大2 FLOPの性能を引き出すことが可能です。

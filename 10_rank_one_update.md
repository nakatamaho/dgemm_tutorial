# ランク-1アップデートによるDGEMM最適化

## ナイーブ実装の問題点

行列乗算（DGEMM）の最も単純な実装では、ドット積を用いて結果行列 $`C`$ の各要素を計算します。この方法では、$`C`$ の各要素を計算するたびに主記憶から $`2K`$ 個の要素（行列 $`A`$ から $`K`$ 個、行列 $`B`$ から $`K`$ 個）を読み出す必要があります。マイクロカーネル（サイズ $`m_R \times n_R`$）全体では $`2K \cdot m_R \cdot n_R`$ 個のメモリロードが発生し、これはメモリ帯域幅のボトルネックとなります。

## レジスタ積み上げ方式（アウトプロダクト法）

この問題を解決するため、レジスタを効率的に活用するアウトプロダクト法（レジスタ積み上げ方式とも呼ばれる）を用います：

1. $`C`$ をゼロで初期化し、全体をレジスタに保持します（$`m_R`$, $`n_R`$ が小さいため可能）
2. $`k = 1, 2, \ldots, K`$ について繰り返し：
   - $`A`$ の1列と $`B`$ の1行をロード
   - それらの外積を計算し、結果を $`C`$ に累積

このアプローチの核心となるのが**ランク-1アップデート**（rank-1 update）と呼ばれる操作です。

## ランク-1アップデートの詳細

### 理論的背景

ランク-1行列とは、ベクトル $`x \in \mathbb{R}^{m_R}`$ と $`y \in \mathbb{R}^{n_R}`$ の外積 $`x y^T`$ で生成される行列であり、その行列のランクが1であることを意味します。

マイクロカーネルでは、各イテレーションで次のランク-1アップデート操作を行います：

```math
C \mathrel{+}= x y^T
```

これは、現在の $`C`$ の値にランク-1行列 $`x y^T`$ を加算する操作です。行列乗算全体を複数のランク-1アップデートの和として表現することで、メモリアクセスを大幅に削減できます。

![ランク1アップデート](rankone_update.svg)

### ランク-1アップデート方式の効率性

ランク-1アップデート方式では、メモリアクセスを大幅に削減できます。理由は、計算方法の根本的な違いにあります。

ナイーブな実装とランク-1アップデート方式を比較すると：

**ナイーブな実装（ドット積方式）**:
- 結果行列 $`C`$ の各要素（$`C_{ij}`$）を計算するとき、行列 $`A`$ の $`i`$ 行目全体（$`K`$ 個の要素）と行列 $`B`$ の $`j`$ 列目全体（$`K`$ 個の要素）を毎回メモリからロードします
- $`m_R \times n_R`$ の小行列ブロック全体では、$`2K \times m_R \times n_R`$ 回のメモリアクセスが必要

**ランク-1アップデート方式（外積方式）**:
- $`C`$ の小行列ブロック全体をレジスタに保持します
- 各イテレーションでは、$`A`$ から $`m_R`$ 個の要素（1列）と $`B`$ から $`n_R`$ 個の要素（1行）だけをロードします
- $`K`$ 回のイテレーションでは、メモリアクセスは合計 $`K \times (m_R + n_R)`$ 回だけ

つまり、通常のドット積計算では各要素計算ごとに大量のデータをロードし直すのに対し、ランク-1アップデート方式では少量のデータのロードで多くの計算を行い、結果をレジスタ上で蓄積していくため、メモリアクセス回数が大幅に削減されます。

$`m_R`$ と $`n_R`$ が大きいほど削減効果も大きくなり、多くの場合、計算速度はメモリ帯域幅によって制限されるため、このメモリアクセス削減は性能向上に直結します。

### ナイーブ実装とランク-1アップデートの比較例

同じ行列計算で両方の方式を比較してみましょう。

# 2×2行列でのナイーブ実装とランク-1アップデートの比較

最もシンプルな2×2行列の乗算でも、両方の実装方法の違いが明確に現れます。

## 例題の設定
次の2×2行列乗算を考えます：

```
A (2×2行列):     B (2×2行列):
[ a11 a12 ]     [ b11 b12 ]
[ a21 a22 ]     [ b21 b22 ]
```

## ナイーブな実装（ドット積方式）

各要素を個別に計算します：

- C[0,0]の計算：
  1. Aの1行目をロード：[a11, a12]（2要素）
  2. Bの1列目をロード：[b11, b21]（2要素）
  3. ドット積計算：a11×b11 + a12×b21

- C[0,1]の計算：
  1. Aの1行目をロード：[a11, a12]（再度2要素）
  2. Bの2列目をロード：[b12, b22]（2要素）
  3. ドット積計算：a11×b12 + a12×b22

- C[1,0]の計算：
  1. Aの2行目をロード：[a21, a22]（2要素）
  2. Bの1列目をロード：[b11, b21]（再度2要素）
  3. ドット積計算：a21×b11 + a22×b21

- C[1,1]の計算：
  1. Aの2行目をロード：[a21, a22]（再度2要素）
  2. Bの2列目をロード：[b12, b22]（再度2要素）
  3. ドット積計算：a21×b12 + a22×b22

**合計メモリアクセス**: 2×2×2×2 = 16回

## ランク-1アップデート方式（外積方式）

行列C全体をレジスタに保持します：

1. Cをゼロで初期化
2. k=0のイテレーション：
   - Aから1列目をロード：[a11, a21]（2要素）
   - Bから1行目をロード：[b11, b12]（2要素）
   - 外積計算と累積：
     ```
     C += [ a11 ] × [ b11 b12 ] = [ a11×b11  a11×b12 ]
          [ a21 ]                  [ a21×b11  a21×b12 ]
     ```

3. k=1のイテレーション：
   - Aから2列目をロード：[a12, a22]（2要素）
   - Bから2行目をロード：[b21, b22]（2要素）
   - 外積計算と累積：
     ```
     C += [ a12 ] × [ b21 b22 ] = [ a12×b21  a12×b22 ]
          [ a22 ]                  [ a22×b21  a22×b22 ]
     ```

**合計メモリアクセス**: (2+2)×2 = 8回

## 比較

- ナイーブ実装：16回のメモリアクセス
- ランク-1方式：8回のメモリアクセス（**50%削減**）

この結果から、2×2という小さな行列でも、ランク-1アップデート方式は効率的にメモリアクセスを削減することがわかります。この削減効果はKの値に関係なく、m_RとnRの比率によって決まります。

ランク-1アップデート方式の効率性の本質は、「一度ロードしたデータを複数の計算に再利用する」点にあります。これにより、行列サイズやKの値にかかわらず、常に効率改善が得られます。

#### 要素数の比較

- **ランク-1アップデート**: 読み込む要素数 = $`(m_R + n_R)K`$ 個
- **ナイーブ実装**: 読み込む要素数 = $`2m_R \cdot n_R \cdot K`$ 個



#### 削減比率

削減の比率は次の式で表されます:

```math
\frac{2m_R \cdot n_R \cdot K}{(m_R+n_R)K} = \frac{2m_R \cdot n_R}{m_R+n_R}
```

#### 具体例

例えば、$`m_R = n_R = 4`$ の場合:

```math
\frac{2 \cdot 4 \cdot 4}{4 + 4} = \frac{32}{8} = 4
```

つまり、メモリアクセスが**1/4**に削減されます。

さらに、$`m_R = n_R = 8`$ の場合:

```math
\frac{2 \cdot 8 \cdot 8}{8 + 8} = \frac{128}{16} = 8
```

このケースでは、メモリアクセスが**1/8**にまで削減されます。

### スケーリング特性

$`m_R`$ と $`n_R`$ の値が大きくなるほど、この削減効果はさらに増大します。これは特に大規模な行列演算において顕著な効率改善をもたらします。理論的には、これらの値が大きければ大きいほど、メモリアクセスの削減効果は向上します。

しかし、実際の実装では、$`m_R`$ と $`n_R`$ の値は利用可能なレジスタメモリによって制約されます。レジスタは高速だが容量が限られているメモリであるため、無限に大きな値を設定することはできません。したがって、ハードウェアの制約の中で最適な値を選択する必要があります。

Ryzen3970Xには、AVX2をサポートしていて、YMM0-YMM15まで16本、256bitのレジスタがあります。これは、binary64は64bitなので、64個持つことができます。つまりCのブロックはぎりぎり8x8まで持てます。ただしぎりぎりだとあふれてしまう(レジスタスピル)こともあり、いろいろな値を試し多少余裕を持った値を使うのが良いと思われます。

### 実装例

以下は、レジスタ上での実装の疑似コード例です：

```
// レジスタにロード済みのベクトル A_reg[0..m_R-1], B_reg[0..n_R-1] を用いる
for i in 0..m_R-1:
    for j in 0..n_R-1:
        C_reg[i * ldc + j] += A_reg[i] * B_reg[j]
```

この実装では、`ldc`（leading dimension of C）を使用して行列Cのメモリレイアウトを正確に表現しています。この操作は、すべてのメモリアクセスをレジスタ内の読み書きに置き換え、メモリ帯域幅の制約を回避します。演算コストは $`m_R \times n_R`$ 回の乗算累加（multiply-accumulate）であり、FMA（Fused Multiply-Add）命令を用いることで1サイクルあたり最大2 FLOPを実現可能です。

# 09 ブロッキングの数理 (Blocking)

> **狙い** — 本節では、行列積 *C ← A B* を「ブロック（タイル）」単位で計算できる**数学的な根拠**を示し、さらにキャッシュ階層と結び付けてブロックサイズを選ぶ指針を概観します。実装テクニックは次章で詳述し、ここではあくまで理論的背景にフォーカスします。

---

## 1 なぜブロッキングが必要か

ハイエンド CPU では、浮動小数点演算性能 (FLOP/s) とメモリ帯域 (B/s) の比—いわゆる **Roofline モデル**の `算術集約度`—が年々開いています。配列要素を `1 回` しか再利用できないアルゴリズムはメモリ帯域に律速され、理論演算ピークのごく一部しか発揮できません。

行列積 `DGEMM` は `` `$O(N^3)$` `` の演算量に対し、要素の総転送量は `` `$O(N^2)$` `` です。各要素を `` `$O(N)$` `` 回再利用できるため、うまくメモリ局所性を確保すれば帯域律速を回避できます。これを実現する最も直接的な手段が `ブロッキング` です。

---

## 2 行列をブロックで表す

まず、$`A\in\mathbb{R}^{m\times k}`$ と `$B\in\mathbb{R}^{k\times n}$` を一様サイズ `b` の正方ブロックに分割するとします（端部は切り詰めるか不完全ブロックになります）。整数

```
$p = \lceil m/b \rceil,\; q = \lceil k/b \rceil,\; r = \lceil n/b \rceil$
```

を用いると、例えば `A` は次のように書けます。

```math
$$
A = \begin{bmatrix}
  A_{00} & \cdots & A_{0,q-1} \\
  \vdots & \ddots & \vdots \\
  A_{p-1,0} & \cdots & A_{p-1,q-1}
\end{bmatrix},\quad
A_{ij}\in\mathbb{R}^{b_i\times b_j}
$$
```

`B` も同様にブロック化できます。

---

## 3 ブロック行列積の定理

> **定理 1 (ブロック行列積)** — 上記のブロック分割に対して、行列積 `C = A B` を同じブロック形に並べると

```math
$$
C_{ij} = \sum_{\ell=0}^{q-1}A_{i\ell}\,B_{\ell j}\quad(0\le i<p,\;0\le j<r)
$$
```

が成り立ちます。ここで `C_{ij}\in\mathbb{R}^{b_i\times b_j}` は `C` の `(i,j)` ブロックです。

### 証明

各 `C_{ij}` の `(α,β)` 成分 (`0\leα<b_i,0\leβ<b_j`) を展開すると

```
(C_{ij})_{αβ} = \sum_{x=0}^{k-1} A_{i,α,x}\;B_{x,j,β}
```

ですが、添字 `x` はブロック幅 `b` ごとに区切れます。`x=ℓb+γ` と置くと `ℓ` がブロック番号 (`0\leℓ<q`)、`γ` がブロック内オフセット (`0\leγ<b_ℓ`) です。

```math
$$
(C_{ij})_{αβ}
= \sum_{ℓ=0}^{q-1}\sum_{γ=0}^{b_ℓ-1}
  A_{iℓ,αγ}\,B_{ℓj,γβ}
= (A_{iℓ}B_{ℓj})_{αβ}
$$
```

よって主張が示されました。\qed

**帰結**
- 乗算はブロック単位で完全に独立に行える。
- 三重ループ版と**アルゴリズム的に同値**。

---

## 4 メモリ階層とブロックサイズの指針 (Ryzen 3970X)

以下では **Ryzen Threadripper 3970X** の“1コア当たり”キャッシュ容量をもとに、
ワーキングセット

```
W = 2N^2 × 8 [bytes]
```

（行列2枚をロードし1枚を書き戻す、倍精度8bytes）を特定キャッシュに収めるときの行列サイズ `N_max` を導出します。

| 階層              | 容量 `C`           | `N_max = floor(sqrt(C/16))` |
|-------------------|--------------------|-----------------------------:|
| **L1 Data**       | 32,768 B           | **`≈45`**                    |
| **L2**            | 524,288 B          | **`≈181`**                   |
| **L3** (共有)     | 134,217,728 B      | **`≈2896`**                  |

> **補足**
> - マイクロカーネルは `32–64` が一般的で、理論上限の `≈45` と整合。
> - Instruction+Data 64KB で考えると `N_max≈64` になるが、実データ専有は32KB。

---

## 5 数値安定性について一言

ブロッキングは演算の集合同「順序」を変えず、ループ粒度を粗くするだけです。

- 結果は理論上完全一致。
- 丸め誤差は加算順序の違いに起因し、微小な差異が発生する場合あり。

---

## 6 まとめ

1. ブロッキングはブロック行列へ再構成することで**数学的同値**を保証。
2. キャッシュ効率向上により**算術集約度**を最大化、帯域律速を回避。
3. ブロックサイズはキャッシュ容量の平方根に比例：
   - L1 用: `32–64`
   - L2 用: `≈180`
   - L3 用: `≈2,900`

次章では、これらを踏まえた**マルチレベルブロック分割**とSIMD化の実装戦略を解説します。


# 09 ブロッキングの数理 (Blocking)

> **狙い** — 本節では、行列積 C ← A B を「ブロック（タイル）」単位で計算できる**数学的な根拠**を示し、さらにキャッシュ階層と結び付けてブロックサイズを選ぶ指針を概観します。実装テクニックは次章で詳述し、ここではあくまで理論的背景にフォーカスします。

---

## 1 なぜブロッキングが必要か

ハイエンド CPU では、浮動小数点演算性能 (FLOP/s) とメモリ帯域 (B/s) の比—いわゆる Roofline モデルの算術集約度—が年々開いています。配列要素を 1 回しか再利用できないアルゴリズムはメモリ帯域に律速され、理論演算ピークのごく一部しか発揮できません。

DGEMM は演算量が O(N³)、メモリ転送量が O(N²) なので、各要素を O(N) 回再利用できれば帯域律速を回避できます。これを実現する最も直接的な手段が **ブロッキング** です。

---

## 2 行列をブロックで表す

まず、A∈ℝⁿᵐˣᵏ と B∈ℝᵏˣⁿ を一様サイズ b の正方ブロックに分割するとします（端部は切り詰めるか不完全ブロック）。整数 p,q,r を
<script type="math/tex; mode=display">
p=\lceil m/b \rceil,\; q=\lceil k/b \rceil,\; r=\lceil n/b \rceil
</script>
として、A は

```text
A = [ A₀₀ ⋯ A₀,q₋₁
      ⋮     ⋱  ⋮
      Aₚ₋₁,₀ ⋯ Aₚ₋₁,q₋₁ ],
```

各 Aᵢⱼ∈ℝᵇⁱˣᵇʲ（bᵢ,bⱼ≤b）と表せます。B も同様です。

---

## 3 ブロック行列積の定理

> **定理 1 (ブロック行列積)** — 上記のブロック分割に対し、C=AB の (i,j) ブロックは
>
<script type="math/tex; mode=display">
C_{ij} = \sum_{\ell=0}^{q-1} A_{i\ell}\,B_{\ell j},\quad 0\le i<p,\;0\le j<r
</script>

### 証明

(C_{ij})_{αβ} を展開すると
<script type="math/tex; mode=display">
(C_{ij})_{\alpha\beta} = \sum_{x=0}^{k-1} A_{i,\alpha,x}\;B_{x,j,\beta}
</script>
添字 x=ℓb+γ (0≤ℓ<q,0≤γ<bₗ) と区切ると
<script type="math/tex; mode=display">
(C_{ij})_{\alpha\beta} = \sum_{\ell=0}^{q-1}\sum_{\gamma=0}^{b_{\ell}-1} A_{i\ell,\alpha\gamma}\;B_{\ell j,\gamma\beta} = (A_{i\ell}B_{\ell j})_{\alpha\beta}
</script>
∴ 定理成立。

### 帰結

- 乗算はブロック単位で独立に実行可能
- 三重ループの k ループを幅 b ごとに粗く刻んだだけで同値

---

## 4 キャッシュ階層とブロックサイズの指針 (Ryzen 3970X)
ワーキングセット W は行列 2 枚ロード＋1 枚書込で
<script type="math/tex; mode=display">
W = 2N^2 \times 8 \;[bytes]
</script>
と表せ、キャッシュ容量 C に対して W≤C を満たす Nₘₐₓ を求めると:

| 階層            | 容量 C          | Nₘₐₓ = ⌊√(C/16)⌋ |
|----------------|---------------:|-----------------:|
| L1 Data (32 KB) | 32 768 B       | ≈ 45             |
| L2 (512 KB)     | 524 288 B      | ≈ 181            |
| L3 (128 MB)     | 134 217 728 B  | ≈ 2 896          |

> **メモ**  
> - マイクロカーネルは N≈32–64 を選定するため、理論上限 45 と整合  
> - Instruction+Data=64 KB を仮定すると Nₘₐₓ≈64 だが実データは約 32 KB  
> - 単スレッド解析では 1 コア L2／共有 L3 見積が精度よし

---

## 5 数値安定性について

ブロッキングは加算順序以外の演算順序を変えず、理論結果は一致。丸め誤差差異は加算順序のみ。

---

## 6 まとめ

1. ブロッキングは数学的同値を保証  
2. キャッシュ効率を上げ帯域律速を回避  
3. ブロックサイズは √C に比例 (L1:32–64, L2:≈180, L3:≈2 900)

次章でマルチレベルブロック＋SIMD 実装を解説します。


# 行列-行列積の基本プログラム

この節では、2つの行列の積を計算する基本的なCプログラムを紹介します。これはDGEMM（Dense General Matrix Multiply）の前段階として基礎的な実装です。

## 行列データの取り扱いとメモリ配置

行列計算のパフォーマンスを考える上で、メモリアクセスパターンは非常に重要です。現代のコンピュータアーキテクチャでは、メモリは階層構造になっており、CPUキャッシュ（L1, L2, L3）→メインメモリ（RAM）→ディスクという順で速度が遅くなります。効率的なプログラムを書くためには、この階層構造を意識する必要があります。

### 連続アクセスの重要性

CPUはメモリからデータを読み込む際、必要な個所だけでなく周辺のデータも含めたブロック（キャッシュライン）単位で読み込みます。このため、連続したメモリ領域に順番にアクセスする方が、バラバラの場所にアクセスするよりも圧倒的に高速です。これを「空間的局所性」と呼びます。

### Row-Major vs Column-Major

メモリ上での2次元配列の配置方法には、主に2つの方式があります：

1. **Row-Major（行優先）**: 行ごとにメモリに格納する方式。C, C++, Pythonなどで採用。
   ```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] ⟷ [1, 2, 3, 4]
                                            [5, 6, 7, 8]
                                            [9, 10, 11, 12]
   ```

2. **Column-Major（列優先）**: 列ごとにメモリに格納する方式。FORTRAN, MATLAB, Rなどで採用。
   ```
[1, 5, 9, 2, 6, 10, 3, 7, 11, 4, 8, 12] ⟷ [1, 2, 3, 4]
                                           [5, 6, 7, 8]
                                           [9, 10, 11, 12]
   ```

### C/C++の二次元配列の問題点

1. **言語仕様上の行列型がない**  
   二次元配列は「一次元配列の入れ子」に過ぎず、専用の行列型が存在しない。

2. **部分行列の抽出が煩雑**  
   サブマトリックス機能がなく、ポインタ演算やオフセット計算を自前で実装する必要がある。

3. **不連続メモリによるキャッシュミス**  
   `double **A` のように行単位で個別確保すると、各行が非連続に配置され、キャッシュ効率が低下。

4. **二重間接参照のオーバーヘッド**  
   `A[i][j]` ではまず `A[i]` のポインタ取得→要素参照の2段階アクセスが発生。

5. **動的拡張の困難さ**  
   行列サイズ変更には再確保やデータコピーが必要で、可変長行列を安全かつ効率的に扱いにくい。

6. **Row-/Column-Majorの不一致**  
   プラットフォームやライブラリでデータレイアウトが異なり、移植時に変換処理が必要になる。

   
### なぜFORTRANの方が行列計算に適しているか
FORTRANは二次元配列の考え方が言語仕様に入っているため、自然に行列を扱えます。FORTRANでは、列優先（Column-Major）のメモリレイアウトを使用します。以下のような利点があります。
1. **部分行列へのアクセスが可能**: 特定の部分行列（サブマトリックス）を扱いたい場合、leading dimensionの考えがFORTRAN自身に組み込まれてるため、自然。
2. **連続したメモリ割り当て**: FORTRANの二次元配列は連続したメモリ領域に割り当てられます。
3. **BLAS/LAPACKとの互換性**: 線形代数の標準ライブラリであるBLAS（Basic Linear Algebra Subprograms）やLAPACK（Linear Algebra PACKage）はFORTRANで開発されており、FORTRANの仕様であるColumn-Majorを前提としています。

### 1次元配列への展開

最も良いアプローチは、2次元配列を1次元配列として表現し、明示的なインデックス計算を行うことだと筆者は考えています：

```c
// 行優先（Row-Major）の場合
int index_row_major(int i, int j, int n_cols) {
    return i * n_cols + j;
}

// 列優先（Column-Major）の場合
int index_col_major(int i, int j, int n_rows) {
    return j * n_rows + i;
}
```

この方法には以下の利点があります：

1. **連続したメモリ確保**: 一度に必要なサイズのメモリを確保するため、メモリアクセス効率、キャッシュ効率が良くなります。

2. **明示的な制御**: どのメモリレイアウトを使うか（行優先か列優先か）を選択できます。

3. **間接参照の削減**: ポインタの間接参照が減り、アクセス速度が向上します。

4. **最適化の余地**: コンパイラによる最適化がより効果的に働きます。

## C言語による基本実装（一次元配列版）
さて、先ほどのセクションでも行った行列積を今度は一次元配列で実装してみましょう。

```c
#include <stdio.h>
#include <stdlib.h>

// 行列の表示関数
void print_matrix(double *matrix, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%.2f\t", matrix[i * cols + j]);
        }
        printf("\n");
    }
    printf("\n");
}

// 行列積を計算する関数
void matrix_multiply(double *A, double *B, double *C, int m, int n, int k) {
    // A: m x k行列
    // B: k x n行列
    // C: m x n行列（結果）
    
    // 結果行列Cを0で初期化
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            C[i * n + j] = 0.0;
        }
    }
    
    // 行列積の計算
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            for (int p = 0; p < k; p++) {
                C[i * n + j] += A[i * k + p] * B[p * n + j];
            }
        }
    }
}

// 使用例
int main() {
    int m = 3; // 行列Aの行数
    int k = 2; // 行列Aの列数、行列Bの行数
    int n = 4; // 行列Bの列数
    
    // 行列のメモリ確保（連続した領域を一度に確保）
    double *A = (double *)malloc(m * k * sizeof(double));
    double *B = (double *)malloc(k * n * sizeof(double));
    double *C = (double *)malloc(m * n * sizeof(double));
    
    // 行列Aの初期化（行優先）
    A[0 * k + 0] = 1.0; A[0 * k + 1] = 2.0;
    A[1 * k + 0] = 3.0; A[1 * k + 1] = 4.0;
    A[2 * k + 0] = 5.0; A[2 * k + 1] = 6.0;
    
    // 行列Bの初期化（行優先）
    B[0 * n + 0] = 1.0; B[0 * n + 1] = 2.0; B[0 * n + 2] = 3.0; B[0 * n + 3] = 4.0;
    B[1 * n + 0] = 5.0; B[1 * n + 1] = 6.0; B[1 * n + 2] = 7.0; B[1 * n + 3] = 8.0;
    
    printf("行列 A (%dx%d):\n", m, k);
    print_matrix(A, m, k);
    
    printf("行列 B (%dx%d):\n", k, n);
    print_matrix(B, k, n);
    
    // 行列積の計算
    matrix_multiply(A, B, C, m, n, k);
    
    printf("行列 C = A x B (%dx%d):\n", m, n);
    print_matrix(C, m, n);
    
    // メモリ解放（一度に解放できる）
    free(A);
    free(B);
    free(C);
    
    return 0;
}
```

このプログラムでは、前のセクションで説明した通り、行列を一次元配列としてメモリに格納しています。行優先（Row-Major）形式を使用し、要素 $(i,j)$ へのアクセスには `matrix[i * cols + j]` という計算式を使用しています。

この実装には以下の利点があります：

1. **メモリ効率**：連続したメモリブロックを一度に確保するため、キャッシュの効率が良くなります。
2. **シンプルなメモリ管理**：確保と解放が簡単です。
3. **高速なアクセス**：間接参照がなくなり、配列要素へのアクセスが高速になります。

一次元配列を使った実装は直感的ではないかもしれませんが、高性能な行列計算アルゴリズムではほぼ必須の手法です。実際、BLAS/LAPACKなどの線形代数ライブラリも内部的には一次元配列を使用しています。

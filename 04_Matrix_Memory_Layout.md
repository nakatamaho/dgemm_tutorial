# 行列データの取り扱いとメモリ配置

**TL; DR C/C++で行列は一次元配列として確保。メモリレイアウトはcolumn majorを採用。leading dimensionも開いて明示的に入れよ**

行列計算のパフォーマンスを考える上で、メモリアクセスパターンは非常に重要です。現代のコンピュータアーキテクチャでは、メモリは階層構造になっており、CPUキャッシュ(L1, L2, L3)→メインメモリ(RAM)→ディスクという順で速度が遅くなります。効率的なプログラムを書くためには、この階層構造を意識する必要があります。

## 連続アクセスの重要性

CPUはメモリからデータを読み込む際、必要な個所だけでなく周辺のデータも含めたブロック(キャッシュライン)単位で読み込みます。このため、連続したメモリ領域に順番にアクセスする方が、バラバラの場所にアクセスするよりも圧倒的に高速です。これを「空間的局所性」と呼びます。

## Row-Major vs Column-Major、このチュートリアルではColumn-Major

メモリ上での2次元配列の配置方法には、主に2つの方式があります:

1. **Row-Major(行優先)**: 行ごとにメモリに格納する方式。C, C++, Pythonなどで採用。
```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] ⟷ [1, 2, 3, 4]
                                            [5, 6, 7, 8]
                                            [9, 10, 11, 12]
```

2. **Column-Major(列優先)**: 列ごとにメモリに格納する方式。FORTRAN, MATLAB, Rなどで採用。
```
[1, 5, 9, 2, 6, 10, 3, 7, 11, 4, 8, 12] ⟷ [1, 2, 3, 4]
                                           [5, 6, 7, 8]
                                           [9, 10, 11, 12]
```
どちらでもokです。従って各プログラムでどちらを取るかは好みの問題になります。このチュートリアルではFORTRAN77やFortran90との互換性をとるため、一貫して、column majorを用いることにします。

## C/C++の二次元配列の問題点

1. **言語仕様上の行列型がない**  
   二次元配列は「一次元配列の入れ子」に過ぎず、専用の行列型が存在しない。C99以降のCではVLA + ポインタもあるがC++では使えない。C/C++は非常にフレキシブルなので実装のやり方が沢山あって他のプログラムとの統一が取れない。

2. **静的確保と動的確保の違い**  
   静的に確保する場合と動的に確保する場合、A[i][j]のようにアクセスはできるが、実現方法が全く値がちがう。静的だと本物の二次元配列と理解されるが、動的だと行単位にメモリを確保する。ポインタとしても互換性はない。

3. **部分行列の抽出が煩雑**  
   サブマトリックス機能がなく、ポインタ演算やオフセット計算を自前で実装する必要がある。

4. **不連続メモリによるキャッシュミス**  
   `double **A` のように行単位で個別確保すると、各行が非連続に配置され、キャッシュ効率が低下。

5. **二重間接参照のオーバーヘッド**  
   `A[i][j]` ではまず `A[i]` のポインタ取得→要素参照の2段階アクセスが発生。

6. **Row-/Column-Majorの不一致**  
   プラットフォームやライブラリでデータレイアウトが異なり、移植時に変換処理が必要になる。

   
## FORTRANは行列計算に適している
FORTRANは二次元配列の考え方が言語仕様に入っているため、自然に行列を扱えます。FORTRANでは、列優先（Column-Major）のメモリレイアウトを使用します。以下のような利点があります。
1. **部分行列へのアクセスが可能**: 特定の部分行列（サブマトリックス）を扱いたい場合、leading dimensionの考えがFORTRAN自身に組み込まれてるため、自然。SIZEで二次元配列のleading dimesionわかります。
2. **連続したメモリ割り当て**: FORTRANの二次元配列は連続したメモリ領域に割り当てられます。
3. **実装の統一が容易**: 行列を実現するため二次元配列を用いるのが標準、かつ、C++/Cのようにプログラムの自由度が少ないため、統一がしやすい。
4. **BLAS/LAPACKとの互換性**: 線形代数の標準ライブラリであるBLAS（Basic Linear Algebra Subprograms）やLAPACK（Linear Algebra PACKage）の大部分はFORTRAN77で開発されており、FORTRAN77の仕様であるColumn-Majorを前提としています。

### 1次元配列への展開

C/C++で2次元を配列を実現する最も良いアプローチは、2次元配列を1次元配列として表現し、明示的にインデックス計算を行うことです。

この方法には以下の利点があります：

1. **連続したメモリ確保**: 一度に必要なサイズのメモリを確保するため、メモリアクセス効率、キャッシュ効率が良くなります。

2. **明示的な制御**: どのメモリレイアウトを使うか（行優先か列優先か）を選択できます。

3. **間接参照の削減**: ポインタの間接参照が減り、アクセス速度が向上します。

4. **最適化の余地**: コンパイラによる最適化がより効果的に働きます。

## C言語による基本実装（一次元配列版）
さて、先ほどのセクションでも行った行列積を今度は一次元配列でインデックスを陽にするようにして実装してみましょう。

```c
#include <stdio.h>
#include <stdlib.h>

// 行列の表示関数（列優先）
void print_matrix(double *matrix, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%.2f\t", matrix[i + j * rows]);
        }
        printf("\n");
    }
    printf("\n");
}

// 行列積（列優先）: C = A × B
void matrix_multiply(double *A, double *B, double *C, int m, int n, int k) {
    // A: m x k（列優先）
    // B: k x n（列優先）
    // C: m x n（列優先）

    // Cを0で初期化
    for (int j = 0; j < n; j++) {
        for (int i = 0; i < m; i++) {
            C[i + j * m] = 0.0;
        }
    }

    // C(i,j) += A(i,p) * B(p,j)
    for (int j = 0; j < n; j++) {
        for (int p = 0; p < k; p++) {
            for (int i = 0; i < m; i++) {
                C[i + j * m] += A[i + p * m] * B[p + j * k];
            }
        }
    }
}

// 使用例
int main() {
    int m = 3; // Aの行数
    int k = 2; // Aの列数 = Bの行数
    int n = 4; // Bの列数

    double *A = (double *)malloc(m * k * sizeof(double)); // m×k
    double *B = (double *)malloc(k * n * sizeof(double)); // k×n
    double *C = (double *)malloc(m * n * sizeof(double)); // m×n

    // 行列Aの初期化（列優先）
    A[0 + 0 * m] = 1.0; A[1 + 0 * m] = 3.0; A[2 + 0 * m] = 5.0;
    A[0 + 1 * m] = 2.0; A[1 + 1 * m] = 4.0; A[2 + 1 * m] = 6.0;

    // 行列Bの初期化（列優先）
    B[0 + 0 * k] = 1.0; B[1 + 0 * k] = 5.0;
    B[0 + 1 * k] = 2.0; B[1 + 1 * k] = 6.0;
    B[0 + 2 * k] = 3.0; B[1 + 2 * k] = 7.0;
    B[0 + 3 * k] = 4.0; B[1 + 3 * k] = 8.0;

    printf("行列 A (%dx%d):\n", m, k);
    print_matrix(A, m, k);

    printf("行列 B (%dx%d):\n", k, n);
    print_matrix(B, k, n);

    matrix_multiply(A, B, C, m, n, k);

    printf("行列 C = A x B (%dx%d):\n", m, n);
    print_matrix(C, m, n);

    free(A);
    free(B);
    free(C);
    return 0;
}
```

このプログラムでは、前のセクションで説明した通り、行列を一次元配列としてメモリに格納しています。行優先（Row-Major）形式を使用し、要素 $(i,j)$ へのアクセスには `matrix[i * cols + j]` という計算式を使用しています。

この実装には以下の利点があります：

1. **メモリ効率**：連続したメモリブロックを一度に確保するため、キャッシュの効率が良くなります。
2. **シンプルなメモリ管理**：確保と解放が簡単です。
3. **高速なアクセス**：間接参照がなくなり、配列要素へのアクセスが高速になります。

一次元配列を使った実装は直感的ではないかもしれませんが、高性能な行列計算アルゴリズムではほぼ必須の手法です。実際、FORTRANでも二次元配列は、内部的にはleading dimensionをもった一次元配列として実装されています。

## おまけ
std::vector<double> は一次配列です。これで行列が表現できるのでこれを使うのもいいのかもしれません。が、leading dimensionは管理してもらえません。

# パネル化:L2キャッシュからL3キャッシュへの拡張への布石

## はじめに

DGEMMの最適化において、CPUのキャッシュ階層を効率的に活用することが性能向上の鍵となります。前回のチュートリアルでは4×4のマイクロカーネルを実装し、L1/L2キャッシュに収まる小～中規模の行列では良好なパフォーマンスを達成しました。しかし、グラフからは、行列サイズがL2キャッシュの容量を超える（グラフの約1000付近）と、パフォーマンスが著しく低下していることがわかります。これには多段ブロックが有効です。ただいきなり多段ブロックを行うのはプログラムとしては難しくなります。したがって、マイクロカーネルの次の段階ブロック化として、パネル化技術の導入を行います。マイクロカーネルでは、アップデートされる部分のブロック化されたCはレジスタにありますが、A, B全体はL2に入っていることが前提です。次のブロック化としては、パネル化を行うことです。つまり、大きなA, Bを分割してL2に入れるということです。まず、ナイーブなパネル化を実装し、次にAのパネルの転置を行います。パネル化は実装上も利点があります。つまり転置やAB行列のα倍にも対応しやすくなります。残念ながらここで遅くなります。最適化しているはずなのに遅くなるのはフラストレーションが溜まりますが、少し我慢です。

## 現在の実装の限界

現在の実装では、行列を4×4の小さなブロックに分割して処理しています：

```cpp
#define MR 4
#define NR 4

// Process by blocks (MR x NR blocks)
for (int j = 0; j < n; j += NR) {
    for (int i = 0; i < m; i += MR) {
        // 小さなブロックをコピーして処理
        // ...
    }
}
```

この方法は、小さなブロックがL1/L2キャッシュに収まる場合には効果的ですが、大きな行列では以下の問題が発生します：

1. **頻繁なキャッシュミス**: 行列が大きいと、行列A、Bから繰り返しデータを読み込む際にL2キャッシュミスが頻発する
2. **メインメモリへの過剰なアクセス**: L3キャッシュが効果的に活用されず、メインメモリからの低速な読み込みが増加する
3. **データの局所性の低下**: 大きな行列では、時間的・空間的局所性が十分に活用されない

## パネル化技術の導入

L3キャッシュを効果的に活用するためには、より大きなブロックサイズを導入した多段階のブロック分割が必要です。ただ、いきなり多段のブロック化を行うのは大変で
大きな行列を効率的に処理するために、まず「パネル化」（Panelization）と呼ばれる技術を考慮します：

```cpp
#define CACHELINE 64
#if defined(__GNUC__) || defined(__clang__)
    #define ALIGN(x) __attribute__((aligned(x)))
#elif defined(_MSC_VER)
    #define ALIGN(x) __declspec(align(x))
#else
    #define ALIGN(x)
#endif

ALIGN(CACHELINE) static double Apanel[MC * KC];
ALIGN(CACHELINE) static double Bpanel[KC * NC];

// L3レベルのループ内で
// Aからパネルにコピー
for (int i = 0; i < ib; i++) {
    for (int p = 0; p < pb; p++) {
        Apanel[i + p * MC] = A[(i + i0) + (p + p0) * lda];
    }
}

// Bからパネルにコピー
for (int p = 0; p < pb; p++) {
    for (int j = 0; j < jb; j++) {
        Bpanel[p + j * KC] = B[(p + p0) + (j + j0) * ldb];
    }
}
```

パネル化により、L2キャッシュに収まるサイズのデータブロックを作成し、そのブロック内での計算を最適化できます。

# パネルの転置

## 転置によるメモリアクセスの最適化

ここからは行列の転置がDGEMM性能に与える影響について説明します。C/C++では配列は行優先（row-major）で格納されるため、行列乗算のような処理では、メモリアクセスパターンが非効率になる場合があります。

## 行列Bをそのまま使用する実装

最初の実装では、行列Bをそのままの形で使用しています：

```cpp
// Allocate temporary buffers
double Apanel[MC * KC];


// Copy B and multiply by alpha - k rows x NR columns panel
for (int jj = 0; jj < NR; jj++) {
    for (int l = 0; l < k; l++) {
        Bpanel[l + jj * k] = alpha * B[l + (j + jj) * ldb];
    }
}

// マイクロカーネルでのアクセス
double b0 = B[l + 0 * ldb];
double b1 = B[l + 1 * ldb];
double b2 = B[l + 2 * ldb];
double b3 = B[l + 3 * ldb];
```
この方法では、マイクロカーネル内で行列Bの要素にアクセスする際、`l`が変化すると大きなメモリアドレスの変化（ストライド）が生じます。このような非連続的なメモリアクセスはキャッシュミスを引き起こし、パフォーマンスを低下させる原因となります。

## 行列Bを転置して使用する実装

提供されたコードサンプルの2つ目の実装では、行列Bをコピーする際に転置を行っています：

```cpp
// Allocate temporary buffers - 転置するので NCxKC
double Bpanel[NC*KC];

// Copy B panel and transpose it for better cache utilization
for (int jj = 0; jj < NR; jj++) {
    for (int l = 0; l < k; l++) {
            Bpanel[l + jj * k] = alpha * B[l + (j + jj) * ldb];
        }
}

// マイクロカーネルでのアクセス（転置済みのアクセスパターン）
double b0 = B[l + 0 * ldb];
double b1 = B[l + 1 * ldb];
double b2 = B[l + 2 * ldb];
double b3 = B[l + 3 * ldb];
```
この実装ではカーネル内ではコード自体は同じになってます。しかし転置をとったことで、重要な変更点が2つあります：

1. **カーネルの変更点の少なさ**: 元のB行列では離れた位置にあるデータが、Bpanelでは隣接して配置されるため、パフォーマンスが向上します。
2. **コピー時の転置**: 内側と外側のループが入れ替わり、データを転置しながらコピーします。ついでにαもかけておきます。

## 転置した場合の計算結果

![DGEMM ベンチマークプロット](14/dgemm_benchmark_comparison_plot.png)

1. パネルへのコピーが入るため、どうしても遅くなります。4x4のカーネルは、コピーが入らないため、その分のパフォーマンス落ちません。
2. 行列のサイズが64, 128, 256の倍数のときにパフォーマンスが落ちます。これは、キャッシュのL1/L2 キャッシュの セット衝突 (conflict-miss)が起こるのが主な原因です。少しずらすと改善します。対処は後に行う予定です。たとえば、IntelMKLでも[Tip 6: Avoid Leading Dimensions that are Multiples of 256](https://www.intel.com/content/www/us/en/developer/articles/technical/a-simple-example-to-measure-the-performance-of-an-intel-mkl-function.html)となってます。
3. どのようなサイズでもnaive実装、4x4カーネル版より遅くなります。心理的には苦しいところです。

## 転置による性能への影響

転置を行うことで以下のメリットがあります：

1. **カーネルの一元化**: 転置をカーネル外に追い出すことにより、プログラミングの手間が減ります。
2. **連続メモリアクセス**: マイクロカーネル内での計算時、lが変化しても連続したメモリ領域にアクセスできる
3. **キャッシュヒット率の向上**: 連続メモリアクセスによりキャッシュラインの利用効率が上がる
4. **プリフェッチの効率化**: 連続アクセスパターンはCPUのハードウェアプリフェッチャが効率的に機能する

一般に、行列サイズが大きくなるほど、転置によるメリットが顕著になります。

## 結論

行列乗算の最適化では、キャッシュ階層を考慮したブロック分割と、効率的なメモリアクセスパターンを実現するための転置が重要です。L3キャッシュへの最適化を進める際には、多段階のブロック分割を導入し、各レベルでのデータアクセスパターンを最適化することで、大規模な行列でも高いパフォーマンスを達成できます。ここでは、マイクロカーネルの一つ上のパネル化について実装しました。

実際の実装では、様々なブロックサイズや転置の有無をベンチマークしながら、最適な構成を見つけることが重要です。

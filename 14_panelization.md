# DGEMM最適化: L2キャッシュからL3キャッシュへの拡張への布石

## はじめに

DGEMM（Double precision GEneral Matrix Multiplication）の最適化において、CPUのキャッシュ階層を効率的に活用することが性能向上の鍵となります。前回のチュートリアルでは4×4のマイクロカーネルを実装し、L1/L2キャッシュに収まる小～中規模の行列では良好なパフォーマンスを達成しました。しかし、提供されたグラフから、行列サイズがL2キャッシュの容量を超える（グラフの約1000付近）と、パフォーマンスが著しく低下していることがわかります。

## 現在の実装の限界

現在の実装では、行列を4×4の小さなブロックに分割して処理しています：

```cpp
// Process by blocks (MR x NR blocks)
for (int j = 0; j < n; j += NR) {
    for (int i = 0; i < m; i += MR) {
        // 小さなブロックをコピーして処理
        // ...
    }
}
```

この方法は、小さなブロックがL1/L2キャッシュに収まる場合には効果的ですが、大きな行列では以下の問題が発生します：

1. **頻繁なキャッシュミス**: 行列が大きいと、行列A、Bから繰り返しデータを読み込む際にL2キャッシュミスが頻発する
2. **メインメモリへの過剰なアクセス**: L3キャッシュが効果的に活用されず、メインメモリからの低速な読み込みが増加する
3. **データの局所性の低下**: 大きな行列では、時間的・空間的局所性が十分に活用されない

## 階層的ブロック分割の導入

L3キャッシュを効果的に活用するためには、より大きなブロックサイズを導入した多段階のブロック分割が必要です：

```cpp
// L3キャッシュレベルのブロックサイズ
const int MC = 256;  // L3キャッシュに適したAのブロックサイズ
const int NC = 256;  // L3キャッシュに適したCのブロックサイズ
const int KC = 256;  // 内側のループの分割サイズ

// L3キャッシュレベルの分割
for (int j = 0; j < n; j += NC) {
    int jb = std::min(NC, n - j);
    
    for (int p = 0; p < k; p += KC) {
        int pb = std::min(KC, k - p);
        
        // L2キャッシュレベルの分割
        for (int i = 0; i < m; i += MC) {
            int ib = std::min(MC, m - i);
            
            // 既存の4×4マイクロカーネルでさらに分割
            // ...
        }
    }
}
```

この階層的なアプローチにより：
- L3キャッシュを有効活用できる
- データの再利用性が向上する
- メインメモリへのアクセスが減少する

## ループ順序の最適化

ループの順序もパフォーマンスに大きな影響を与えます。最適なループ順は以下の要素に依存します：

- データアクセスパターン
- キャッシュサイズ
- データの再利用パターン

一般的には、C行列の更新を最も外側のループにすることで、C行列のデータを可能な限り長くキャッシュに保持できます。これは「jip」順（j→i→p）や「ijp」順などと呼ばれることもあります。

## パネル化技術の導入

大きな行列を効率的に処理するために、「パネル化」（Panelization）と呼ばれる技術も考慮します：

```cpp
// パネル行列用のバッファを確保
double *Apanel = (double *)aligned_alloc(64, MC * KC * sizeof(double));
double *Bpanel = (double *)aligned_alloc(64, KC * NC * sizeof(double));

// L3レベルのループ内で
// Aからパネルにコピー
for (int i = 0; i < ib; i++) {
    for (int p = 0; p < pb; p++) {
        Apanel[i + p * MC] = A[(i + i0) + (p + p0) * lda];
    }
}

// Bからパネルにコピー
for (int p = 0; p < pb; p++) {
    for (int j = 0; j < jb; j++) {
        Bpanel[p + j * KC] = B[(p + p0) + (j + j0) * ldb];
    }
}
```

パネル化により、L3キャッシュに収まるサイズのデータブロックを作成し、そのブロック内での計算を最適化できます。

## パフォーマンスチューニングの方向性

L3キャッシュ最適化において重要なポイントは以下の通りです：

1. **ブロックサイズの選定**: 各キャッシュレベルに適したブロックサイズを選定（経験則やキャッシュサイズから決定）
   - 典型的な値: MC = NC = 256〜512、KC = 256程度

2. **アライメント**: メモリアライメント（通常は64バイト境界）を考慮し、キャッシュラインの利用効率を最大化

3. **プリフェッチ**: 明示的なプリフェッチ命令の活用や、プリフェッチに優しいアクセスパターンの採用

# DGEMM最適化: 転置

## 転置によるメモリアクセスの最適化

ここからは行列の転置がDGEMM性能に与える影響について説明します。C/C++では配列は行優先（row-major）で格納されるため、行列乗算のような処理では、メモリアクセスパターンが非効率になる場合があります。

## 行列Aをそのまま使用する実装

最初の実装では、行列Aをそのままの形で使用しています：

```cpp
// Allocate temporary buffers
double Ablock[MR * KMAX];

// Copy A - MR rows x k columns block
for (int l = 0; l < k; l++) {
    for (int ii = 0; ii < MR; ii++) {
        Ablock[ii + l * MR] = A[(i + ii) + l * lda];
    }
}

// マイクロカーネルでのアクセス
double a0 = A[0 + l * lda];
double a1 = A[1 + l * lda];
double a2 = A[2 + l * lda];
double a3 = A[3 + l * lda];
```

この方法では、マイクロカーネル内で行列Aの要素にアクセスする際、`l`が変化すると大きなメモリアドレスの変化（ストライド）が生じます。このような非連続的なメモリアクセスはキャッシュミスを引き起こし、パフォーマンスを低下させる原因となります。

## 行列Aを転置して使用する実装

提供されたコードサンプルの2つ目の実装では、行列Aをコピーする際に転置を行っています：

```cpp
// Allocate temporary buffers - 転置するので k×MR
double Ablock[KMAX * MR];

// Copy A while transposing - k rows x MR columns block (after transpose)
for (int ii = 0; ii < MR; ii++) {
    for (int l = 0; l < k; l++) {
        Ablock[l + ii * k] = A[(i + ii) + l * lda];
    }
}

// マイクロカーネルでのアクセス（転置済みのアクセスパターン）
double a0 = A[l + 0 * lda];
double a1 = A[l + 1 * lda];
double a2 = A[l + 2 * lda];
double a3 = A[l + 3 * lda];
```

この実装では、重要な変更点が2つあります：

1. **行列Aの格納方法**: `Ablock`のメモリレイアウトが`KMAX * MR`となり、データの物理的な配置が変わります。
2. **コピー時の転置**: 内側と外側のループが入れ替わり、データを転置しながらコピーします。

## 転置による性能への影響

転置を行うことで以下のメリットがあります：

1. **連続メモリアクセス**: マイクロカーネル内での計算時、lが変化しても連続したメモリ領域にアクセスできる
2. **キャッシュヒット率の向上**: 連続メモリアクセスによりキャッシュラインの利用効率が上がる
3. **プリフェッチの効率化**: 連続アクセスパターンはCPUのハードウェアプリフェッチャが効率的に機能する

しかし、転置にはコストも伴います：

1. **コピーオーバーヘッド**: 転置のための追加のコピー操作が必要
2. **メモリ使用量の増加**: 転置された行列を保存するための追加のメモリが必要

これらのオーバーヘッドにより、特に小さな行列では転置による性能向上が相殺される場合があります。一般に、行列サイズが大きくなるほど、転置によるメリットが顕著になります。

## L3キャッシュ最適化における転置の位置づけ

L3キャッシュを活用する多段階ブロック分割においても、転置は重要な最適化技術です。パネル行列をコピーする際に転置を行うことで、より効率的なメモリアクセスパターンを実現できます：

```cpp
// Aパネルをコピーして転置
for (int p = 0; p < pb; p++) {
    for (int i = 0; i < ib; i++) {
        Apanel[p + i * KC] = A[(i + i0) + (p + p0) * lda];  // 転置
    }
}
```

ただし、L3キャッシュレベルでの転置は、コピーオーバーヘッドが大きくなるため、慎重に評価する必要があります。場合によっては、転置を行わない方が全体の性能が向上することもあります。

## 結論

行列乗算の最適化では、キャッシュ階層を考慮したブロック分割と、効率的なメモリアクセスパターンを実現するための転置が重要です。L3キャッシュへの最適化を進める際には、多段階のブロック分割を導入し、各レベルでのデータアクセスパターンを最適化することで、大規模な行列でも高いパフォーマンスを達成できます。

転置は強力な最適化技術ですが、そのオーバーヘッドも考慮する必要があります。実際の実装では、様々なブロックサイズや転置の有無をベンチマークしながら、最適な構成を見つけることが重要です。

# NoAVX 4x4マイクロカーネルによるDGEMM高速化

## マイクロカーネルとは

行列乗算（DGEMM）の最適化において、マイクロカーネルは非常に重要な役割を果たします。マイクロカーネルとは、小さな固定サイズのブロック（この場合は4x4）に対して高度に最適化された行列乗算のコードで、DGEMMの内側のループを効率的に実行するために設計されています。

## NoAVX 4x4マイクロカーネルの実装

今回実装したNoAVX 4x4マイクロカーネルは、AVX2などのSIMD命令を使わずにスカラー演算だけで実装された基本的なマイクロカーネルです。以下に実装の特徴を示します：

```cpp
void noavx_micro_kernel_4x4(int k, const double *A, int lda,
                           const double *B, int ldb, double *C, int ldc) {
    // 一時変数に計算結果を蓄積
    double c00 = 0.0, c01 = 0.0, c02 = 0.0, c03 = 0.0;
    double c10 = 0.0, c11 = 0.0, c12 = 0.0, c13 = 0.0;
    double c20 = 0.0, c21 = 0.0, c22 = 0.0, c23 = 0.0;
    double c30 = 0.0, c31 = 0.0, c32 = 0.0, c33 = 0.0;
    
    // k方向に行列積を計算
    for (int l = 0; l < k; l++) {
        // Aの要素をロード
        double a0 = A[0 + l * lda];
        double a1 = A[1 + l * lda];
        double a2 = A[2 + l * lda];
        double a3 = A[3 + l * lda];
        
        // Bの要素をロード
        double b0 = B[l + 0 * ldb];
        double b1 = B[l + 1 * ldb];
        double b2 = B[l + 2 * ldb];
        double b3 = B[l + 3 * ldb];
        
        // 行列積の計算（16個の乗算と加算）
        c00 += a0 * b0; c01 += a0 * b1; c02 += a0 * b2; c03 += a0 * b3;
        c10 += a1 * b0; c11 += a1 * b1; c12 += a1 * b2; c13 += a1 * b3;
        c20 += a2 * b0; c21 += a2 * b1; c22 += a2 * b2; c23 += a2 * b3;
        c30 += a3 * b0; c31 += a3 * b1; c32 += a3 * b2; c33 += a3 * b3;
    }
    
    // 結果をCに格納
    C[0 + 0 * ldc] = c00; C[0 + 1 * ldc] = c01; C[0 + 2 * ldc] = c02; C[0 + 3 * ldc] = c03;
    C[1 + 0 * ldc] = c10; C[1 + 1 * ldc] = c11; C[1 + 2 * ldc] = c12; C[1 + 3 * ldc] = c13;
    C[2 + 0 * ldc] = c20; C[2 + 1 * ldc] = c21; C[2 + 2 * ldc] = c22; C[2 + 3 * ldc] = c23;
    C[3 + 0 * ldc] = c30; C[3 + 1 * ldc] = c31; C[3 + 2 * ldc] = c32; C[3 + 3 * ldc] = c33;
}
```

### 最適化のポイント

1. **ループアンロール**: 内側のループを完全にアンロールし、レジスタ再利用を最大化
2. **データの局所性**: 4x4の小さなブロック単位で処理することでキャッシュ効率を向上
3. **レジスタの活用**: 計算途中の結果を一時変数（レジスタ）に保持し、メモリアクセスを削減
4. **命令レベル並列性**: コンパイラが命令をパイプライン化しやすい構造

## 性能比較と分析

GitHubのベンチマーク比較プロットを見ると、NoAVX 4x4マイクロカーネル実装が単純なトリプルループ実装（ナイーブな実装）と比較してどの程度高速化されているかがわかります。

一般的な傾向として、以下のような特性が観察できます：

1. **小さなサイズ（L1キャッシュ内）**: マイクロカーネル実装は、ループのオーバーヘッドが減少するためナイーブな実装よりも多少高速化される傾向があります。

2. **中サイズ（L2キャッシュ内）**: マイクロカーネル実装の優位性はさらに顕著になります。これは、ブロック化によってキャッシュ効率が大幅に向上するためです。

3. **大きなサイズ（L3キャッシュ以上）**: メモリアクセスのパターンが最適化されるため、マイクロカーネル実装は大きな行列サイズでも性能の劣化を抑えることができます。

4. **ピーク性能**: マイクロカーネル実装は特定のサイズでピーク性能を発揮します。これは多くの場合、L2キャッシュに収まるサイズであることが多いです。

## マイクロカーネル実装の意義

NoAVX 4x4マイクロカーネルの実装は、以下の理由で重要です：

1. **基礎的な最適化技術の理解**: SIMD命令を使わなくても、適切なループアンロールとレジスタ利用によって性能を向上させられることを示しています。

2. **メモリ階層の重要性**: 計算よりもメモリアクセスが律速になるケースが多いという現代のコンピュータアーキテクチャの特性を理解するのに役立ちます。

3. **発展的な最適化への橋渡し**: AVX2やAVX-512などのSIMD命令を使った高度な最適化の基礎となります。

## 教訓

NoAVX 4x4マイクロカーネルの実装から得られる主な教訓は以下の通りです：

1. **ブロック化の重要性**: 大きな問題を小さなブロックに分割することで、キャッシュ効率を劇的に向上させることができます。

2. **レジスタ再利用の最大化**: メモリアクセスを減らし、計算途中の結果をレジスタに保持することで性能を向上させることができます。

3. **命令レベル並列性の活用**: 現代のCPUはパイプライン化と命令レベル並列性に大きく依存しており、適切にコードを構造化することでこれらを活用できます。

次のステップとしては、SIMD命令（AVX2、AVX-512など）を活用して、より高度なマイクロカーネルを実装することで、さらなる性能向上が期待できます。また、ブロッキング戦略の最適化やパネル化、マルチスレッド化なども検討すべき発展的な最適化技術です。

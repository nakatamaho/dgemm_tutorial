# デバッグしやすいDGEMMの結果のプリント方法

ここでは、デバッグしやすいDGEMMの結果のプリント方法について述べます。コツは、行列の要素とスカラーにランダムかつ絶対値小さめの整数を入力することです。
これで画面に表示しても行列が見やすくなり、整数演算になるので正解と誤差ゼロで比較できること、octaveにコピペして正解と比較する、の三つの意味でデバッグしやすくなります。

## 1. ソフトウェアの準備

### BLAS と Octave のインストール

以下のようにして、BLAS と Octave をインストールします（Debian/Ubuntu系の例）:

```bash
$ sudo apt update
$ sudo apt install libopenblas-dev octave
```

- **libopenblas-dev**: BLAS (Basic Linear Algebra Subprograms) のライブラリを使うための開発用パッケージ  
- **octave**: MATLAB 互換の数値計算ソフトウェア  

---

## 2. テストプログラムのビルドと実行

サンプルコードが置かれている `dgemm_debug_print` ディレクトリに移動し、`make` を実行してビルドします:

```bash
$ cd dgemm_debug_print
$ make
```

ビルドに成功すると、`./dgemm_debug_print` という実行ファイルが生成されます。これを実行すると、以下のように行列 \( A, B, C \) やスカラー \( \alpha, \beta \) がランダムに生成され、その行列と最終的な結果がコンソールに表示されます。実行してみましょう。なお、結果は毎回ランダムなので、実行結果はかならずしも以下のようにはなりませんが似たようなものになるはずです。

```bash
$ ./dgemm_debug_print
A = [
        7     4     1     7;
        2     9     8     6;
       -1     9    -4    -2;
       -3    -7    -4    -6
];

B = [
       -9     9     1    -8;
        2    -6     0     4;
        2     8    -2     4;
       -7     0     3     3
];

C = [
        3     6     5     7;
       -7    -7     0    -1;
        4     9    -7     8;
        7     0    -7    -2
];

alpha = -5;
beta  = -3;

C_blas = [
      501  -253  -145    54;
      151  -119   -20  -347;
     -177   448    16  -134;
     -256    85    86   196
];

C = alpha * A * B + beta * C; ;
C_blas - C
```
---

## 3. Octave での動作確認

上の出力をそのまま Octave にコピー＆ペーストすると、計算結果が再現されます。実行例を示します:

```bash
$ ./dgemm_debug_print | octave
ans =

   0   0   0   0
   0   0   0   0
   0   0   0   0
   0   0   0   0
```

ここで表示されている `ans` がゼロ行列になっています。これは、**`C_blas - C` がすべて 0 である → 実装した DGEMM が BLAS での計算結果と一致している** ことを意味します。

---

## 4. 出力を見やすくするポイント

1. 小さめのランダムな整数行列を用いることで、手計算比較および目視確認がしやすくなります。
   今回は-9, 9までランダムな整数のみを行列要素に用いるため、計算結果は必ず整数になります。これを四桁～五桁程度でフォーマットすると、画面にコンパクトに出力でき、視認性が高くなります。

2. 小さめのランダムな整数行列を用いることで、何回か試して正解と誤差がゼロならばバグなしとできます。
   今回は-9, 9までランダムな整数のみを行列要素に用いるため、計算結果は必ず整数になります。このため、浮動小数点による誤差がなくなり、正解との比較が飛躍的にやりやすくなります。ここで例えば、-10, 10までランダムなの浮動小数点数を用いると、相対誤差が1e-16程度になります。確かにこれでokなのですが、例えば、1e-13程度になると浮動小数点による計算誤差が溜まって相対誤差が大きくなったのか、単にバグなのか、わかりにくくなります。この利点は倍精度ではなく、単精度や半精度ならばより顕著になります。ただし万能ではありません。オーバーフローと、非常に低い確率でバグを正解としてしまう可能性があることに注意しましょう。

3. **Octave への貼り付けを想定したフォーマット**  
   スカラーと行列の出力部分を、Octave が理解できる構文（`A = [...]; B = [...]; C = [...];` のように）で表示するようにすると、例えば自分で実装したDGEMMとoctaveとのクロスチェックが容易になります。

---

## 5. まとめ

- **DGEMM が正しく動作しているか** を確認するには、
  1. **同一の行列・スカラーを使って**、
  2. **実装した DGEMM と BLAS あるいは他の数値計算ソフトウェア(Octave など) での結果** を比較する  
  という方法がシンプルで確実です。  

- **小さめのランダムな整数でスカラーと行列を作り、プリントすると**
  1. 数桁に収まるため目視しやすい。浮動小数点を用いると桁が長くなるため、目視しづらくなる。
  2. より信頼できるプログラムと比較でき、**バグなしならば誤差ゼロ**だけでなく、その逆である**誤差ゼロならばバグなし**がいえる。

- 出力を **Octave 形式で表示** し、**Octave 上でコピペして実際に `C_blas - C` を計算する** と、目で見て誤差がゼロかどうかを確認できます。  

このように **テストコードを通じて計算結果を可視化** し、さらに **Octave など他のツールで同じ計算を再現して差分を確認** することで、実装した DGEMM が正しく動作しているかを簡単に検証できます。
